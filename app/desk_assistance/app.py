import typing as t
from enum import Enum
from typing import Self
from abc import abstractmethod, ABC
import asyncio
import contextlib

from desk_assistance.config import AppConfig
from desk_assistance.plugin import PluginsBearer, Plugin
from desk_assistance.event import Event


class App(PluginsBearer["AppPlugin"]):
    def __init__(self, *, config: AppConfig | None = None):
        super().__init__()

        self._config: AppConfig = config or AppConfig()

    @property
    def config(self) -> AppConfig:
        return self._config

    @classmethod
    def create(cls, *, config: AppConfig) -> Self:
        app = cls(config=config)

        # TODO: Load plugins
        plugins = []

        for plugin in plugins or []:
            app.register(plugin)

        return app

    async def _run(self):
        async with self:
            await self.trigger(AppRunEvent())

            await self.trigger(AppCloseEvent())

    def run(self):
        # TODO: Raise exception if this or any other app instance is currently
        #  running. Also consider if this check should be here or at `App._run`
        #  method.

        asyncio.run(self._run())


class AppPlugin(Plugin[App], ABC):
    """
    Plugin applicable to App instance
    """

    @abstractmethod
    async def on_app_run(self):
        ...

    @abstractmethod
    async def on_app_close(self):
        ...


class AppEventType(str, Enum):
    APP_RUN = "APP_RUN"
    APP_CLOSE = "APP_CLOSE"


class AppEvent(Event[AppPlugin]):
    """
    Event generated by App instance
    """

    EVENT_TYPE: AppEventType


class AppRunEvent(AppEvent):
    """
    Event generated on App run
    """

    EVENT_TYPE: t.Literal[AppEventType.APP_RUN] = AppEventType.APP_RUN


class AppCloseEvent(AppEvent):
    """
    Event generated on App close
    """

    EVENT_TYPE: t.Literal[AppEventType.APP_CLOSE] = AppEventType.APP_CLOSE
