import typing as t
from enum import Enum
from typing import Self
from abc import abstractmethod, ABC
import asyncio
import contextlib

from desk_assistance import exc
from desk_assistance.config import AppConfig
from desk_assistance.plugin import PluginsBearer, Plugin
from desk_assistance.event import Event


class App(PluginsBearer["AppPlugin"]):
    def __init__(self, *, config: AppConfig | None = None):
        super().__init__()

        self._config: AppConfig = config or AppConfig()

    @property
    def config(self) -> AppConfig:
        return self._config

    @classmethod
    def create(cls, *, config: AppConfig) -> Self:
        app = cls(config=config)

        # TODO: Load plugins
        plugins = []

        for plugin in plugins or []:
            app.register(plugin)

        return app

    async def run(self):
        if not self.context_entered:
            raise exc.MissingContext(
                f"You are unable to run {self} for now. Please ensure context "
                f"when dealing with {self.__class__.__name__} context "
                f"dependent methods."
            )

        await self.trigger(AppRunEvent())

        ...

        await self.trigger(AppCloseEvent())


class AppPlugin(Plugin[App], ABC):
    """
    Plugin applicable to App instance
    """

    @abstractmethod
    async def on_app_run(self):
        ...

    @abstractmethod
    async def on_app_close(self):
        ...


class AppEventType(str, Enum):
    APP_RUN = "APP_RUN"
    APP_CLOSE = "APP_CLOSE"


class AppEvent(Event[AppPlugin]):
    """
    Event generated by App instance
    """

    EVENT_TYPE: AppEventType


class AppRunEvent(AppEvent):
    """
    Event generated on App run
    """

    EVENT_TYPE: t.Literal[AppEventType.APP_RUN] = AppEventType.APP_RUN


class AppCloseEvent(AppEvent):
    """
    Event generated on App close
    """

    EVENT_TYPE: t.Literal[AppEventType.APP_CLOSE] = AppEventType.APP_CLOSE
